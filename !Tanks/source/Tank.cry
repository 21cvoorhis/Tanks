import Graphics2D;
import Math;
import Random;
import TwoCansAlpha4;

//note radius is of the box center to the box vertecies (r of hitbox circle and half of the body diagonals)

class Tank : Object{
	
	//body vars
	field bAngle; //angle the body is facing
	field bPoints; //points that make the body's square
	field collisionR; //collision circle's radius
	
	//gun vars
	field gAngle; //angle the gun is facing
	field bullets;
	field maxBullets;
	field bulletSpeed;
	field bulletTime;
	
	constructor(pos, vel, radius, color, maxBullets, bulletSpeed, bulletTime) : base(pos, vel, radius, color){
		
		this.bAngle = 0.0;
		this.bPoints = [[], [], [], []];
		tempAngle = 0.0;
		for(i = 0; i < 4; i++){
			tempAngle = ((Math.PI*2)/4) * i + (Math.PI/4) + this.bAngle;
			this.bPoints[i] = [this.pos[0] + (this.r*Math.cos(tempAngle)), this.pos[1] + (this.r*Math.sin(tempAngle))];
		}
		this.collisionR = this.r/(2**0.5);
		
		this.gAngle = 0.0;
		this.bullets = [];
		this.maxBullets = maxBullets;
		this.bulletSpeed = bulletSpeed;
		this.bulletTime = bulletTime;
		
	}
	
	function updateTank(walls, tanks){
		
		//update bullet info, should run regardless if the tank is alive or not
		for(i = 0; i<this.bullets.length; i++){
			this.bullets[i].updateBullet(walls, tanks);
		}
		
		//update tank info
		this.bCollisionBullets(tanks);
		
		//update bullet alive
		for(i = 0; i<this.bullets.length; i++){
			if(!this.bullets[i].alive){
				this.bullets.remove(i);
			}
		}
		
		//update tank alive
		if(this.alive){
			this.updatePos();
			this.bCollisionWalls(walls);
		}
	}
	
	function shoot(walls){
		if(this.bullets.length < this.maxBullets){
			bx = this.pos[0] + (this.r*cos(this.gAngle));
			by = this.pos[1] + (this.r*sin(this.gAngle));
			if(!this.gCollision([1.3*this.r*cos(this.gAngle) + this.pos[0], 1.3*this.r*sin(this.gAngle) + this.pos[1]], walls)){
				this.bullets.add(new Bullet([bx, by], this.bulletSpeed, this.r*(2.0/5.0), [255, 255, 255], this.gAngle, this.bulletTime));
			}
		}
	}
	
	function bCollisionWalls(walls){
		
		pi = this.pos; //position initial
		pb = this.prevPos; //position before
		
		//resolve collisions with other tanks first, then walls
		
		for(i = 0; i<walls.length; i++){
			if(circleRectCollision(pi, this.collisionR, walls[i])){
				//if shifting pos[0] to prevPos[0] will not cause a collision, make that change
				if(!circleRectCollision([pb[0], pi[1]], this.collisionR, walls[i])){
					//this checks for a glitch (catching) that only happens with a down & left input against the seam of 2 walls horizontally next to each other
					if((i<walls.length) && (walls[i].right == walls[i+1].left) && !circleRectCollision([pi[0], pb[1]], this.collisionR, walls[i])){
						this.pos[1] = this.prevPos[1];
					}else{
						this.pos[0] = this.prevPos[0];
					}
				}else if(!circleRectCollision([pi[0], pb[1]], this.collisionR, walls[i])){
					this.pos[1] = this.prevPos[1];
				}else{
					this.pos[0] = this.prevPos[0];
					this.pos[1] = this.prevPos[1];
				}
			}
		}
	}
	
	function bCollisionBullets(tanks){
		
		for(i = 0; i<tanks.length; i++){
			for(j = 0; j<tanks[i].bullets.length; j++){
				if(pointQuadCollision(tanks[i].bullets[j].pos, this.bPoints)){
					this.alive = false;
				}
			}
		}
		
	}
	
	function gCollision(pos, walls){
		for(wall : walls){
			if(pointRectCollision(pos, wall)){
				return true;
			}
		}
		return false;
	}
	
	function drawTank(){
		
		targetAngle = this.vAngle;
		tempAngle = 0.0;
		gPoints = [[],[],[],[]];
		
		if(this.motion){
			//checks to see if they are further than pi apart, iand adjust target by 2pi to be closer to bAngle
			if(Math.abs(this.bAngle-targetAngle) > Math.PI){
				if(targetAngle > 0){
					targetAngle = targetAngle - (2*Math.PI);
				}else{
					targetAngle = targetAngle + (2*Math.PI);
				}
			}
			
			//uses exponential smoothing with 3 mix values to make the tank turn smoothly
			if(Math.abs(this.bAngle-targetAngle) > Math.PI/4){
				this.bAngle = mix(this.bAngle, targetAngle, 0.1);
			}else if(Math.abs(this.bAngle-targetAngle) > Math.PI/8){
				this.bAngle = mix(this.bAngle, targetAngle, 0.2);
			}else if(Math.abs(this.bAngle-targetAngle) > 0.00001){
				this.bAngle = mix(this.bAngle, targetAngle, 0.3);
			}else{
				this.bAngle = targetAngle;
			}
			
			//adjust bAngle back by 2pi
			if(this.bAngle>Math.PI){
				this.bAngle = this.bAngle - 2*Math.PI;
			}else if(this.bAngle<-Math.PI){
				this.bAngle = this.bAngle + 2*Math.PI;
			}
			
		}	
			
		for(i = 0; i < 4; i++){
			tempAngle = ((Math.PI*2)/4) * i + (Math.PI/4) + this.bAngle;
			this.bPoints[i] = [this.pos[0] + (this.r*Math.cos(tempAngle)), this.pos[1] + (this.r*Math.sin(tempAngle))];
		}
		
		tempAngle = this.gAngle + (Math.PI/2);
		gPoints[0] = [(0.2*this.r*cos(tempAngle)) + this.pos[0], (0.2*this.r*sin(tempAngle)) + this.pos[1]];
		gPoints[1] = [(-0.2*this.r*cos(tempAngle)) + this.pos[0], (-0.2*this.r*sin(tempAngle)) + this.pos[1]];
		
		tempAngle = this.gAngle;
		gPoints[2] = [(1.25*this.r*cos(tempAngle)) + gPoints[1][0], (1.25*this.r*sin(tempAngle)) + gPoints[1][1]];
		gPoints[3] = [(1.25*this.r*cos(tempAngle)) + gPoints[0][0], (1.25*this.r*sin(tempAngle)) + gPoints[0][1]];
		
		//body
		Graphics2D.Draw.quad(this.bPoints[0][0], this.bPoints[0][1], this.bPoints[1][0], this.bPoints[1][1], this.bPoints[2][0], this.bPoints[2][1], this.bPoints[3][0], this.bPoints[3][1], this.color[0], this.color[1], this.color[2]);
		//gun
		Graphics2D.Draw.quad(gPoints[0][0], gPoints[0][1], gPoints[1][0], gPoints[1][1], gPoints[2][0], gPoints[2][1], gPoints[3][0], gPoints[3][1], 0, 0, 0);
		//circle turret
		Graphics2D.Draw.ellipse(this.pos[0]-(this.r*0.6), this.pos[1]-(this.r*0.6), this.r*1.2, this.r*1.2, 0, 0, 0);
		Graphics2D.Draw.ellipse(this.pos[0]-(this.r*0.5), this.pos[1]-(this.r*0.5), this.r, this.r, this.color[0], this.color[1], this.color[2]);
		
	}
	
}