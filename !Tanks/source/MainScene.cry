import Graphics2D;
import Graphics2DText;
import Math;
import Random;
import Resources;
import TwoCansAlpha4;

const DT = (1.0/60.0);
const WIDTH = 640.0;
const HEIGHT = 480.0;

function mix(a, b, amount){
	return (1-amount)*a + amount*b;
}

function triangleArea(x1, y1, x2, y2, x3, y3){
	return Math.abs(((x1*y2)+(x2*y3)+(x3*y1)-(y1*x2)-(y2*x3)-(y3*x1))/2.0);
}

function pointRectCollision(point, rect){
	return
		point[0] > rect.left &&
		point[0] < rect.right &&
		point[1] > rect.top &&
		point[1] < rect.bottom;
}

function pointCircleCollision(point, circlePos, circleR) {
    dx = point[0] - circlePos[0];
    dy = point[1] - circlePos[1];
    return dx ** 2 + dy ** 2 < circleR ** 2;
}

function circleRectCollision(circlePos, circleR, rect){
    if (circlePos[0] + circleR < rect.left) return false;
    if (circlePos[0] - circleR > rect.right) return false;
    if (circlePos[1] + circleR < rect.top) return false;
    if (circlePos[1] - circleR > rect.bottom) return false;

    dx = null;
    dy = null;
    if (circlePos[0] < rect.left) {
        if (circlePos[1] < rect.top) {
            dx = circlePos[0] - rect.left;
            dy = circlePos[1] - rect.top;
        } else if (circlePos[1] > rect.bottom) {
            dx = circlePos[0] - rect.left;
            dy = circlePos[1] - rect.bottom;
        }
    } else if (circlePos[0] > rect.right) {
        if (circlePos[1] < rect.top) {
            dx = circlePos[0] - rect.right;
            dy = circlePos[1] - rect.top;
        } else if (circlePos[1] > rect.bottom) {
            dx = circlePos[0] - rect.right;
            dy = circlePos[1] - rect.bottom;
        }
    }

    if (dx != null) {
        return dx ** 2 + dy ** 2 < circleR ** 2;
    }

    return true;
}

function pointQuadCollision(point, quadPoints){
	
	qTri1 = triangleArea(quadPoints[0][0], quadPoints[0][1], quadPoints[1][0], quadPoints[1][1], quadPoints[2][0], quadPoints[2][1]);
	qTri2 = triangleArea(quadPoints[2][0], quadPoints[2][1], quadPoints[3][0], quadPoints[3][1], quadPoints[0][0], quadPoints[0][1]);
	quadArea = qTri1 + qTri2;
	
	pTris = [];
	for(i = 0; i<4; i++){
		if(i<3){
			pTris.add(triangleArea(point[0], point[1], quadPoints[i][0], quadPoints[i][1], quadPoints[i+1][0], quadPoints[i+1][1]));
		}else{
			pTris.add(triangleArea(point[0], point[1], quadPoints[i][0], quadPoints[i][1], quadPoints[0][0], quadPoints[0][1]));
		}
	}
	pArea = pTris[0] + pTris[1] + pTris[2] + pTris[3];
	
	return !(pArea>quadArea);
}



class MainScene : AbstractScene {
	
	field player;
	field playerColor = [63, 63, 255];
	field badTanks;
	field tanks; //list of all the tanks
	
	field fileName = "levels/TestLevel.txt";
	field mapText;
	field walls = [];
	field wallColor = [63, 63, 63];
	
	field mousePos;
	
	constructor() : base() {
	
		this.badTanks = [];
		
		//border walls
		this.walls.add(new Wall([0,0], 20, HEIGHT, this.wallColor));
		this.walls.add(new Wall([WIDTH-20,0], 20, HEIGHT, this.wallColor));
		this.walls.add(new Wall([0,0], WIDTH, 20, this.wallColor));
		this.walls.add(new Wall([0,HEIGHT-20], WIDTH, 20, this.wallColor));
		
		this.mapText = this.getMapText(this.fileName);
		for(i = 0; i<this.mapText.length; i++){
			switch(this.mapText[i]){
				case 'W':
					this.walls.add(new Wall([20.0+40*(i%15), 20.0+40*Math.floor(i/15)], 40.0, 40.0, this.wallColor));
					break;
				case 'P':
					this.player = new Tank([40+40*(i%15), 40+40*Math.floor(i/15)], 100.0, 20.0, this.playerColor, 5, 200.0, 3.0);
					break;
				/*
				implement some system where the bad tanks have a larger hitbox than the player. if you make a separate badTank class you can put that in the constructor
				*/
			}
		}
		
		this.tanks = this.badTanks.clone();
		this.tanks.add(this.player);
		
		this.mousePos = [0,0];
		
	}
	
	function getMapText(fileName){
		text = "";
		mapText = Resources.readText(fileName);
		for(i = 0; i<mapText.length; i++){
			if(mapText[i]!='\n' && mapText[i]!='\r'){
				text+=mapText[i];
			}
		}
		return text;
	}
	
	function update(inputManager, events) {
		
		this.mousePos = inputManager.getMousePosition();
		
		//player movement
		this.player.target[0] = 0;
		this.player.target[1] = 0;
		if(inputManager.isKeyPressed(KeyboardKey.LEFT) || inputManager.isKeyPressed(KeyboardKey.A)) {
			this.player.target[0]--;
		}
		if (inputManager.isKeyPressed(KeyboardKey.RIGHT) || inputManager.isKeyPressed(KeyboardKey.D)) {
			this.player.target[0]++;
		}
		if(inputManager.isKeyPressed(KeyboardKey.UP) || inputManager.isKeyPressed(KeyboardKey.W)) {
			this.player.target[1]--;
		}
		if (inputManager.isKeyPressed(KeyboardKey.DOWN) || inputManager.isKeyPressed(KeyboardKey.S)) {
			this.player.target[1]++;
		}
		if (inputManager.isKeyPressed(KeyboardKey.R)) {
			this.player.alive = true;
		}
		
		this.player.vAngle = Math.arctan(this.player.target[1], this.player.target[0]);
		
		if(!((this.player.target[0]==0) && (this.player.target[1]==0))){ //if there is a velocity input
			this.player.motion = true;
		}else{
			this.player.motion = false;
		}
		
		this.player.gAngle = Math.arctan(this.mousePos[1]-this.player.pos[1], this.mousePos[0]-this.player.pos[0]);
		
		this.player.updateTank(this.walls, this.tanks); //updating a tank updates the bullets in it as well
		
		for (event : events) {
			switch (event.type) {
				case EventType.MOUSE_PRESS:
					this.player.shoot(this.walls);
					break;
			}
		}
		
	}
	
	function render() {
		
		Graphics2D.Draw.fill(127, 127, 127);
		
		for(i = 0; i<this.tanks.length; i++){
			for(j = 0; j<this.tanks[i].bullets.length; j++){
				this.tanks[i].bullets[j].drawBullet();
			}
		}
		
		for(tank : this.tanks){
			if(tank.alive){
				tank.drawTank();
			}
		}
		
		for(wall : this.walls){
			wall.drawWall();
		}
		
	}
}
