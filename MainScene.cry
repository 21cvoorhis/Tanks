import Graphics2D;
import Graphics2DText;
import Math;
import Random;
import Resources;
import TwoCansAlpha4;

/*
To-do:
- Have tanks not intersect each other, use the 6 snippets interative constraint solving code to do that
	- Make a list of all tanks currently touching
	- Run the constraint solving function for each pair
	- If there are still collisions, run it again
- Add switching levels, and some kind of menu system
	- Give an intro to each level before starting it (like Wii Tanks)
- Find some way to put all of the collision algorithm stuff into another file. Maybe these functions exist on the title screen where you start so they don't have to be on the level? idk
	- You could also have a dummy scene that routes straight to the title screen that contains all these functions, and it's just the start scene when you boot the game.
- Give bullets outlines
- Make destructable walls
	- Collision is just circleRectCollision for an explosion and a wall, but you'll need to adjust the pathfinding algorithm.
		- Add a node every time the list is updated?
- Bucket Collisions (from 6 snippets), bucket size could just be the size of a wall?
	- Create a class that specifically handles collisions
		- Class contains all collision functions listed below and a master function for triage (explained later)
		- At the start of each frame, the class is passed all of the tanks, bullets, explosions etc. and makes a list of which ones to check (using buckets)
			- Assign each object a bucket, and if two share a bucket, check collisions. If more than two share a bucket, check every one with every other one.
			- At the end you have a list of paired objects that should be checked with each other
		- Then it sorts all of them by element. If a pair contains a bullet, put it in the bullet list. Else if a pair contains a mine, put it in a list. Then do explosions, and finally tanks.
		- Then run each pair through the triage function. This function checks the types of both of the list elements, and then sends them off to the appropriate collision function which will change the variables as needed.
		- You don't need to return anything if you pass all the lists in, because the collision class can alter those lists directly.
*/

const BR = 127.0; //background r
const BG = 127.0; //background g
const BB = 127.0; //background b
const DT = (1.0/60.0);
const WIDTH = 640.0;
const HEIGHT = 480.0;

enum ShotType { NONE, DIRECT, BANKED, LEAD }
enum PlantType { NONE, YES }
enum MoveType { NONE, DIRECT, DISTANCE, RANDOM }

//mix
function mix(start, end, amount){
	return (1-amount)*start + amount*end;
}

function mixColor(c1, c2, amount){
	r = mix(c1[0], c2[0], amount);
	g = mix(c1[1], c2[1], amount);
	b = mix(c1[2], c2[2], amount);
	return [r, g, b];
}

function smoothRotate(current, target){ //smoothly interpolate between two angles
	
	if(current == null || target == null){
		return current;
	}
	
	//checks to see if they are further than pi apart, and adjust target by 2pi to be closer to current
	if(Math.abs(current-target) > Math.PI){
		if(target > 0){
			target = target - (2*Math.PI);
		}else{
			target = target + (2*Math.PI);
		}
	}
	
	//uses exponential smoothing with 3 mix values to make the tank turn smoothly
	if(Math.abs(current-target) > Math.PI/4){
		current = mix(current, target, 0.1);
	}else if(Math.abs(current-target) > Math.PI/8){
		current = mix(current, target, 0.2);
	}else if(Math.abs(current-target) > 0.00001){
		current = mix(current, target, 0.3);
	}else{
		current = target;
	}
	
	//adjust bAngle back by 2pi
	if(current>Math.PI){
		return current - 2*Math.PI;
	}else if(current<-Math.PI){
		return current + 2*Math.PI;
	}
	return current;
}

//math
function triangleArea(x1, y1, x2, y2, x3, y3){
	return Math.abs(((x1*y2)+(x2*y3)+(x3*y1)-(y1*x2)-(y2*x3)-(y3*x1))/2.0);
}

//collision
function pointRectCollision(point, rect){
	return
		point[0] > rect.left &&
		point[0] < rect.right &&
		point[1] > rect.top &&
		point[1] < rect.bottom;
}

function pointCircleCollision(point, circlePos, circleR) {
	dx = point[0] - circlePos[0];
	dy = point[1] - circlePos[1];
	return dx ** 2 + dy ** 2 < circleR ** 2;
}

function pointSegmentCollision(point, s) {
	
	d1 = (((s[0][0] - point[0])**2) + ((s[0][1] - point[1])**2))**0.5;
	d2 = ((s[1][0] - point[0])**2 + (s[1][1] - point[1])**2)**0.5;
	
	lineLen = (((s[1][0] - s[0][0])**2) + ((s[1][1] - s[0][1])**2))**0.5;
	
	buffer = 0.1;    // higher # = less accurate
	
	if (d1+d2 >= lineLen-buffer && d1+d2 <= lineLen+buffer) {
		return true;
	}
	return false;
}

function pointQuadCollision(point, quad){
	
	qTri1 = triangleArea(quad[0][0], quad[0][1], quad[1][0], quad[1][1], quad[2][0], quad[2][1]);
	qTri2 = triangleArea(quad[2][0], quad[2][1], quad[3][0], quad[3][1], quad[0][0], quad[0][1]);
	quadArea = qTri1 + qTri2;
	
	pArea = 0.0;
	for(i = 0; i<4; i++){
		if(i<3){
			pArea += (triangleArea(point[0], point[1], quad[i][0], quad[i][1], quad[i+1][0], quad[i+1][1]));
		}else{
			pArea += (triangleArea(point[0], point[1], quad[i][0], quad[i][1], quad[0][0], quad[0][1]));
		}
	}
	
	return !(pArea>quadArea);
}

function circleCircleCollision(c1pos, c1r, c2pos, c2r) {
	dx = c1pos[0] - c2pos[0];
	dy = c1pos[1] - c2pos[1];
	return (dx ** 2) + (dy ** 2) < (c1r + c2r) ** 2;
}

function circleRectCollision(circlePos, circleR, rect){
    if (circlePos[0] + circleR < rect.left) return false;
    if (circlePos[0] - circleR > rect.right) return false;
    if (circlePos[1] + circleR < rect.top) return false;
    if (circlePos[1] - circleR > rect.bottom) return false;

    dx = null;
    dy = null;
    if (circlePos[0] < rect.left) {
        if (circlePos[1] < rect.top) {
            dx = circlePos[0] - rect.left;
            dy = circlePos[1] - rect.top;
        } else if (circlePos[1] > rect.bottom) {
            dx = circlePos[0] - rect.left;
            dy = circlePos[1] - rect.bottom;
        }
    } else if (circlePos[0] > rect.right) {
        if (circlePos[1] < rect.top) {
            dx = circlePos[0] - rect.right;
            dy = circlePos[1] - rect.top;
        } else if (circlePos[1] > rect.bottom) {
            dx = circlePos[0] - rect.right;
            dy = circlePos[1] - rect.bottom;
        }
    }

    if (dx != null) {
        return dx ** 2 + dy ** 2 < circleR ** 2;
    }

    return true;
}

function circleSegmentCollision(circlePos, circleR, s){
	
	inside1 = pointCircleCollision(s[0], circlePos, circleR);
	inside2 = pointCircleCollision(s[1], circlePos, circleR);
	if (inside1 || inside2){
		return true;
	}
	
	distX = s[0][0] - s[1][0];
	distY = s[0][1] - s[1][1];
	len = ((distX*distX) + (distY*distY))**0.5;
	
	// get dot product of the line and circle
	dot = (((circlePos[0]-s[0][0])*(s[1][0]-s[0][0])) + ((circlePos[1]-s[0][1])*(s[1][1]-s[0][1]))) / (len**2);
	
	// find the closest point on the line
	closestX = s[0][0] + (dot * (s[1][0]-s[0][0]));
	closestY = s[0][1] + (dot * (s[1][1]-s[0][1]));
	
	onS = pointSegmentCollision([closestX, closestY], s);
	if (!onS){
		return false;
	}
	
	distX = closestX - circlePos[0];
	distY = closestY - circlePos[1];
	distance = ((distX**2) + (distY**2))**0.5;

	if (distance <= circleR) {
		return true;
	}
	return false;
}

function circleQuadCollision(circlePos, circleR, quad){
	
	if(pointQuadCollision(circlePos, quad)){
		return true;
	}
	
	for(i = 0; i<4; i++){
		if(i<3){
			if(circleSegmentCollision(circlePos, circleR, [quad[i], quad[i+1]])){
				return true;
			}
		}else{
			if(circleSegmentCollision(circlePos, circleR, [quad[i], quad[0]])){
				return true;
			}
		}
	}
	
	return false;
}

function segmentSegmentCollision(s0, s1){ //https://www.geeksforgeeks.org/check-if-two-given-line-segments-intersect/
	
	o1 = orientation(s0[0], s0[1], s1[0]);
	o2 = orientation(s0[0], s0[1], s1[1]);
	o3 = orientation(s1[0], s1[1], s0[0]);
	o4 = orientation(s1[0], s1[1], s0[1]);
	
    // General case
    if(o1 != o2 && o3 != o4){
		return true;
	}
	
    // Special Cases
    if (o1 == 0 && onSegment(s0[0], s1[0], s0[1])){
		return true;
	}
	
    if (o2 == 0 && onSegment(s0[0], s1[1], s0[1])){
		return true;
	}
	
    if (o3 == 0 && onSegment(s1[0], s0[0], s1[1])){
		return true;
	}
	
    if (o4 == 0 && onSegment(s1[0], s0[1], s1[1])){
		return true;
	}
	
    return false; // Doesn't fall in any of the above cases
	
}
function orientation(p0, p1, p2){
	
	val = ((p1[1] - p0[1]) * (p2[0] - p1[0])) - ((p1[0] - p0[0]) * (p2[1] - p1[1]));
	
	if(val == 0){
		return 0; //collinear
	}
	return (val > 0)? 1: 2; //1 = clockwise, 2 = counterclockwise
}
function onSegment(p0, p1, p2){
    if (p1[0] <= max(p0[0], p2[0]) && p1[0] >= Math.min(p0[0], p2[0]) &&
        p1[1] <= max(p0[1], p2[1]) && p1[1] >= Math.min(p0[1], p2[1])){
       return true;
	}
    return false;
}

function segmentSegmentIntersection(s0, s1){
	//ray's starting x and y points (px and py), and parametric component directions (dx and dy)
	r_px = s0[0][0];
	r_py = s0[0][1];
	r_dx = (s0[1][0]-r_px);
	r_dy = (s0[1][1]-r_py);
	
	//same as above for the line segment
	s_px = s1[0][0];
	s_py = s1[0][1];
	s_dx = (s1[1][0]-s_px);
	s_dy = (s1[1][1]-s_py);
	
	//Find if the lines are parallel, if so there's no intersection
	r_mag = (((r_dx*r_dx)+(r_dy*r_dy))**0.5);
	s_mag = (((s_dx*s_dx)+(s_dy*s_dy))**0.5);
	
	//check for /0 error
	if(r_mag==0){
		return null;
	}
	
	if(r_dx/r_mag==s_dx/s_mag && r_dy/r_mag==s_dy/s_mag){
		return null;
	}
	
	//find T1 and T2, for the parametric equations
	try{
		t2 = ((r_dx*(s_py-r_py)) + (r_dy*(r_px-s_px)))/((s_dx*r_dy) - (s_dy*r_dx));
		t1 = (s_px+(s_dx*t2)-r_px)/r_dx;
	}catch(Exception e){
		//catches /0 errors when lines are straight horizontal/vertical
		t2 = ((r_dx*(s_py-r_py)) + (r_dy*(r_px-s_px)))/((s_dx*r_dy) - (s_dy*r_dx));
		t1 = (s_py+s_dy*t2-r_py)/r_dy; //this is added from my previous version because only r_dx ever throws an error
	}
	
	//if the parametric T values are past these parameters the intersection isn't on the segments
	if(t1<0.0 || t1>1.0){
		return null;
	}
	if(t2<-0.00001 || t2>1.00001){
		return null;
	}
	
	//otherwise, you're good, and can plug in all the variables you just found to find the point of intersection [x, y, t]
	return [r_px+(r_dx*t1), r_py+(r_dy*t1), t1];
	
}

//misc. code
function pointsToSegments(points){
	segments = [];
	for(i = 0; i<points.length; i++){
		if(i<points.length-1){
			segments.add([points[i].clone(), points[i+1].clone()]);
		}else{
			segments.add([points[i].clone(), points[0].clone()]);
		}
	}
	return segments;
}

function segmentsEqual(s0, s1){
	return
		(s0[0][0] == s1[0][0] &&
		s0[0][1] == s1[0][1] &&
		s0[1][0] == s1[1][0] &&
		s0[1][1] == s1[1][1]) ||
		(s0[0][0] == s1[1][0] &&
		s0[0][1] == s1[1][1] &&
		s0[1][0] == s1[0][0] &&
		s0[1][1] == s1[0][1]);
}

function listsEqual(l0, l1){
	
	if(l0.length != l1.length){
		return false;
	}
	
	for(i = 0; i<l0.length; i++){
		if(l0[i] != l1[i]){
			return false;
		}
	}
	
	return true;
	
}

function segmentListsEqual(l0, l1){

	if(listsEqual(l0, l1)){
		return true;
	}
	
	for(i = 0; i<l0.length; i++){
		if(!segmentsEqual(l0[i],l1[i])){
			return false;
		}
	}
	
	return true;
	
}

function mergeIntervals(v){
	
	if(v == null || v.length == 0){
		return null;
	}
	
	v = sortIntervals(v);
	intervals = [];
	
	intervals.add([v[0][0], v[0][1]]);
	
	for(i = 1; i<v.length; i++){
		x1 = v[i][0];
		y1 = v[i][1];
		x2 = intervals[intervals.length - 1][0];
		y2 = intervals[intervals.length - 1][1];
		
		if(y2 >= x1) {
			intervals[intervals.length - 1][1] = Math.max(y1, y2);
		} else {
			intervals.add([x1, y1]);
		}
	}
	
	return intervals;
	
}
function sortIntervals(v){
	
	currentList = v;
	finalList = [];
	
	while(currentList.length > 0){
		
		currentMin = currentList[0][0];
		currentMinIndex = 0;
		for(i = 0; i<currentList.length; i++){
			if(currentList[i][0] < currentMin){
				currentMin = currentList[i][0];
				currentMinIndex = i;
			}
		}
		finalList.add(currentList[currentMinIndex]);
		currentList.remove(currentMinIndex);
		
	}
	
	return finalList;
}

function tileToIndex(t){

	if(Math.ensureRange(0, 14, t[0]) == t[0] && Math.ensureRange(0, 10, t[1]) == t[1]){
		return t[0] + t[1] * 15;
	}else{
		return null;
	}
	
}
function tileToPos(t){
	return [40.0+40*(t[0]), 40.0+40*(t[1])];
}
function posToTile(p){
	t = [(p[0]-40.0)/40, (p[1]-40.0)/40];
	for(i = 0; i<t.length; i++){
		dec = t[i] - Math.floor(t[i]);
		if(dec < 0.5){
			t[i] = Math.floor(t[i]);
		}else{
			t[i] = Math.floor(t[i]) + 1;
		}
	}
	return t;
}

function findNode(tile, nodes){
	try{
		n = nodes[tileToIndex(tile)];
		return n;
	}catch(Core.KeyNotFoundException){
		return null;
	}
}

class MainScene : AbstractScene {
	
	field backdropColor = [BR, BG, BB];
	
	field player;
	field playerColor = [63, 63, 255];
	field tanks = []; //list of all the tanks
	
	field fileName = "levels/TestLevel.txt";
	field mapText;
	field wallMapText; //doc but only the walls, for pathfinding
	field gridNodes;
	field cornerNodes;
	field wallDict;
	
	field walls = [];
	field wallSegments = [];
	field wallColor = [63, 63, 63];
	
	field mousePos;
	
	constructor() : base() {
		
		//border walls
		this.walls.add(new Wall([0.0,0.0], 20.0, HEIGHT, this.wallColor));
		this.walls.add(new Wall([WIDTH-20.0,0.0], 20.0, HEIGHT, this.wallColor));
		this.walls.add(new Wall([0,0], WIDTH, 20.0, this.wallColor));
		this.walls.add(new Wall([0.0,HEIGHT-20.0], WIDTH, 20.0, this.wallColor));
		
		this.getMapText(this.fileName);
		for(i = 0; i<this.mapText.length; i++){
			switch(this.mapText[i]){
				case 'W':
					this.walls.add(new Wall([20.0+40*(i%15), 20.0+40*Math.floor(i/15)], 40.0, 40.0, this.wallColor));
					break;
				case 'P':
					this.player = new Tank([40+40*(i%15), 40+40*Math.floor(i/15)], 20.0, this.playerColor, 100.0, 5, 200.0, 1, 2, 10.0);
					break;
				case 'S': //nonmoving direct shot
					this.tanks.add(new BadTank([40+40*(i%15), 40+40*Math.floor(i/15)], 20.0, [191, 63, 63], 0.0, ShotType.DIRECT, 4.0, 5, 200.0, 1, PlantType.NONE, 0, 2, 10.0, MoveType.NONE));
					break;
				case 'R': //nonmoving ricochet shot
					this.tanks.add(new BadTank([40+40*(i%15), 40+40*Math.floor(i/15)], 20.0, [255, 63, 0], 0.0, ShotType.BANKED, 5.0, 5, 200.0, 1, PlantType.NONE, 0, 2, 10.0, MoveType.NONE));
					break;
				case 'M': //moving tank with no attacks
					this.tanks.add(new BadTank([40+40*(i%15), 40+40*Math.floor(i/15)], 20.0, [0, 63, 0], 50.0, ShotType.NONE, 5.0, 5, 200.0, 1, PlantType.NONE, 0, 2, 10.0, MoveType.DIRECT));
					break;
				case 'm': //mine planter
					this.tanks.add(new BadTank([40+40*(i%15), 40+40*Math.floor(i/15)], 20.0, [255, 255, 0], 100.0, ShotType.NONE, 5.0, 5, 200.0, 1, PlantType.YES, 3.0, 2, 10.0, MoveType.RANDOM));
					break;
			}
		}
		this.tanks.add(this.player);
		
		this.getWallMapText(this.mapText);
		
		for(wall : this.walls){
			for(segment : wall.segments){
				this.wallSegments.add(segment);
			}
		}
		this.wallSegments = this.findWallSegments(this.wallSegments);
		
		this.getGridNodes();
		//this.getCornerNodes();
		
		this.mousePos = [0,0];
		
	}
	
	function getMapText(fileName){
		mapText = "";
		fileText = Resources.readText(fileName);
		for(i = 0; i<fileText.length; i++){
			if(fileText[i]!='\n' && fileText[i]!='\r'){
				mapText+=fileText[i];
			}
		}
		this.mapText = mapText;
	}
	
	function getWallMapText(mapText){
		wallMapText = "";
		for(i = 0; i<mapText.length; i++){
			if(mapText[i] == 'W'){
				wallMapText+='W';
			}else{
				wallMapText+='-';
			}
		}
		this.wallMapText = wallMapText;
	}
	
	/*
	Possible wall algorithm?
	- Find each of the corners using the wallSegment list (find all points then sort for only the unique ones)
		- Use the uniqueness sorting from the wallSegment program but instead of removing if two match, do nothing
	- For each corner point found, look at the 4 tiles it touches and search for which one is a wall
	- Once you find the wall one, place a node opposite that wall diagonally
	*/
	
	function getGridNodes(){
		gridNodes = {};
		wallDict = {};
		
		for(i = 0; i<this.wallMapText.length; i++){
			if(this.wallMapText[i] == 'W'){
				wallDict[i] = [i%15, Math.floor(i/15)];
			}else{
				gridNodes[i] = new Node([i%15, Math.floor(i/15)], 1);
			}
		}
		
		for(k : gridNodes.keys()){
			gridNodes[k].getGridNeighbors(gridNodes);
		}
		
		this.gridNodes = gridNodes;
		this.wallDict = wallDict;
	}
	
	/*function getCornerNodes(){
		
		cornerNodes = {};
		
		for(k : this.gridNodes.keys()){
			
			n = this.gridNodes[k];
			if(this.validCornerNode(n, this.wallDict)){
				cornerNodes[tileToIndex(n.tile)] = new Node(n.tile.clone(), 1);
			}
			
		}
		
		for(k : cornerNodes.keys()){
			cornerNodes[k].getCornerNeighbors(cornerNodes, this.wallSegments);
		}
		
		this.cornerNodes = cornerNodes;
		
	}
	
	function validCornerNode(node, wallDict){
		
		dirs = [[1,1], [-1,1], [1,-1], [-1,-1]];
		
		for(d : dirs){
			
			dTile = [node.tile[0] + d[0], node.tile[1] + d[1]];
			dIndex = tileToIndex([node.tile[0] + d[0], node.tile[1] + d[1]]);
			
			try{
				
				wallTile = wallDict[dIndex];
				
				if(!this.wallIsTile([dTile[0], node.tile[1]], wallDict) && !this.wallIsTile([node.tile[0], dTile[1]], wallDict)){
					return true;
				}
				
			}catch(Core.InvalidKeyException){}catch(Core.KeyNotFoundException){} //dIndex was invalid, so that tile can't be checked
			
		}
		
		return false;
		
	}
	function wallIsTile(tile, wallDict){
		
		try{
			test = wallDict[tileToIndex(tile)];
		}catch(Core.KeyNotFoundException){
			return false;
		}
		
		return true;
		
	}
	*/
	
	function findWallSegments(segments){
		
		startList = segments;
		uniqueList = [];
		xDict = {}; //these walls face in the x direction but have the same y points. They're sorted in a dictionary by y level
		xIntervals = [];
		yDict = {};
		yIntervals = [];
		endList = [];
		
		duplicate = false;
		
		//find duplicate segments (two walls on top of each other) and remove both of them
		if(!listsEqual(startList, segments)){
			startList = endList.clone();
		}
		endList = [];
		for(s : startList){
			duplicate = false;
			for(i = 0; i < uniqueList.length; i++){
				if(segmentsEqual(uniqueList[i], s)){
					uniqueList.remove(i);
					duplicate = true;
				}
			}
			if(!duplicate){
				uniqueList.add(s);
			}
		}
		
		//sort points into slope groups
		for(s : uniqueList){
			if(s[0][1] == s[1][1]){
				try{
					xDict[Math.floor(s[0][1])].add(s);
				}catch(Core.KeyNotFoundException){
					xDict[Math.floor(s[0][1])] = [s];
				}
			}else{
				try{
					yDict[Math.floor(s[0][0])].add(s);
				}catch(Core.KeyNotFoundException){
					yDict[Math.floor(s[0][0])] = [s];
				}
			}
		}
		
		//merge each slope group
		for(y : xDict.keys()){
			for(s : xDict[y]){
				if(s[0][0] < s[1][0]){
					xIntervals.add([s[0][0], s[1][0]]);
				}else{
					xIntervals.add([s[1][0], s[0][0]]);
				}
			}
			xIntervals = mergeIntervals(xIntervals);
			for(i : xIntervals){
				endList.add([[i[0], y*1.0],[i[1], y*1.0]]);
			}
			xIntervals = [];
		}
		
		for(x : yDict.keys()){
			for(s : yDict[x]){
				if(s[0][1] < s[1][1]){
					yIntervals.add([s[0][1], s[1][1]]);
				}else{
					yIntervals.add([s[1][1], s[0][1]]);
				}
			}
			yIntervals = mergeIntervals(yIntervals);
			for(i : yIntervals){
				endList.add([[x*1.0,i[0]],[x*1.0, i[1]]]);
			}
			yIntervals = [];
		}
		
		return endList;
		
	}
	
	function update(inputManager, events) {
		
		this.mousePos = inputManager.getMousePosition();
		
		//player movement
		this.player.target[0] = 0;
		this.player.target[1] = 0;
		if(inputManager.isKeyPressed(KeyboardKey.LEFT) || inputManager.isKeyPressed(KeyboardKey.A)) {
			this.player.target[0]--;
		}
		if (inputManager.isKeyPressed(KeyboardKey.RIGHT) || inputManager.isKeyPressed(KeyboardKey.D)) {
			this.player.target[0]++;
		}
		if(inputManager.isKeyPressed(KeyboardKey.UP) || inputManager.isKeyPressed(KeyboardKey.W)) {
			this.player.target[1]--;
		}
		if (inputManager.isKeyPressed(KeyboardKey.DOWN) || inputManager.isKeyPressed(KeyboardKey.S)) {
			this.player.target[1]++;
		}
		if (inputManager.isKeyPressedThisFrame(KeyboardKey.SPACE)) {
			if(this.player.alive){
				this.player.plant();
			}
		}
		if (inputManager.isKeyPressed(KeyboardKey.R)) {
			this.player.alive = true;
		}
		
		if(!((this.player.target[0]==0) && (this.player.target[1]==0))){ //if there is a velocity input
			this.player.vAngle = Math.arctan(this.player.target[1], this.player.target[0]);
		}else{
			this.player.vAngle = null;
		}
		
		this.player.gAngle = Math.arctan(this.mousePos[1]-this.player.pos[1], this.mousePos[0]-this.player.pos[0]);
		
		for (event : events) {
			switch (event.type) {
				case EventType.MOUSE_PRESS:
					if(this.player.alive){
						this.player.shoot(this.walls);
					}
					break;
			}
		}
		
		/*
		All elements of the tanks have to be updated in groups to keep collision information correct, and in this order because they can cause a chain reaction.
		Also, all positions need to be calculated before any collisions.
		I'd love to use for(tank : this.tanks) instead of the standard for loops, but it can throw errors if there are no tanks, bullets, etc.
		Overall, I hate how this code looks and it feels highly inefficient, but it's the best I could come up with that doesn't throw errors everywhere.
		*/
		
		//update object data
		for(i = 0; i<this.tanks.length; i++){
			if(this.tanks[i].alive){
				this.tanks[i].updateObject();
			}
			for(j = 0; j<this.tanks[i].bullets.length; j++){
				this.tanks[i].bullets[j].updateObject();
			}
			for(j = 0; j<this.tanks[i].mines.length; j++){
				this.tanks[i].mines[j].updateObject();
			}
			for(j = 0; j<this.tanks[i].explosions.length; j++){
				this.tanks[i].explosions[j].updateObject();
			}
		}
		
		for(i = 0; i<this.tanks.length; i++){
			for(j = 0; j<this.tanks[i].bullets.length; j++){
				this.tanks[i].bullets[j].updateBullet(this.walls, this.wallSegments, this.tanks);
			}
		}
		for(i = 0; i<this.tanks.length; i++){
			for(j = 0; j<this.tanks[i].mines.length; j++){
				this.tanks[i].mines[j].updateMine(this.tanks);
			}
		}
		for(i = 0; i<this.tanks.length; i++){
			for(j = 0; j<this.tanks[i].explosions.length; j++){
				this.tanks[i].explosions[j].updateExplosion();
			}
		}
		for(i = 0; i<this.tanks.length-1; i++){
			if(this.tanks[i].alive){
				this.tanks[i].updateBadTank(this.walls, this.wallSegments, this.tanks, this.gridNodes, this.cornerNodes);
			}
		}
		if(this.player.alive){
			this.player.updateTank(this.walls, this.tanks);
		}
		
		//update object lists
		for(i = 0; i<this.tanks.length; i++){
			for(j = 0; j<this.tanks[i].bullets.length; j++){
				if(!this.tanks[i].bullets[j].alive){
					if(this.tanks[i].bullets[j].explode){
						this.tanks[i].explosions.add(new Explosion(this.tanks[i].bullets[j].pos.clone(), this.tanks[i].bulletR*2.0, [255, 0, 0], [255, 127, 0]));
					}
					this.tanks[i].bullets.remove(j);
				}
			}
			for(j = 0; j<this.tanks[i].mines.length; j++){
				if(!this.tanks[i].mines[j].alive){
					this.tanks[i].explosions.add(new Explosion(this.tanks[i].mines[j].pos.clone(), this.tanks[i].mineR*8.0, [255, 0, 0], [255, 127, 0]));
					this.tanks[i].mines.remove(j);
				}
			}
			for(j = 0; j<this.tanks[i].explosions.length; j++){
				if(!this.tanks[i].explosions[j].alive){
					this.tanks[i].explosions.remove(j);
				}
			}
		}
		
	}
	
	function render() {
		
		Graphics2D.Draw.fill(BR, BG, BB);
		
		for(i = 0; i<this.tanks.length; i++){
			for(j = 0; j<this.tanks[i].explosions.length; j++){
				this.tanks[i].explosions[j].drawExplosion();
			}
			for(j = 0; j<this.tanks[i].bullets.length; j++){
				this.tanks[i].bullets[j].drawBullet();
			}
			for(j = 0; j<this.tanks[i].mines.length; j++){
				this.tanks[i].mines[j].drawMine();
			}
		}
		
		for(tank : this.tanks){
			if(tank.alive){
				tank.drawTank();
			}
		}
		
		for(wall : this.walls){
			wall.drawWallOutline();
		}
		for(wall : this.walls){
			wall.drawWallInside();
		}
		
		//testing
		for(s : this.wallSegments){
			Graphics2D.Draw.line(s[0][0], s[0][1], s[1][0], s[1][1], 5, 166, 0, 166);
		}
		for(s : this.wallSegments){
			Graphics2D.Draw.ellipse(s[0][0]-5, s[0][1]-5, 10, 10, 0, 255, 0);
			Graphics2D.Draw.ellipse(s[1][0]-5, s[1][1]-5, 10, 10, 0, 255, 0);
		}
		
		/*for(k : this.gridNodes.keys()){
			n = this.gridNodes[k];
			n.drawEdges();
		}
		for(k : this.gridNodes.keys()){
			n = this.gridNodes[k];
			n.drawNode();
		}*/
		
		for(k : this.cornerNodes.keys()){
			n = this.cornerNodes[k];
			n.drawEdges();
		}
		for(k : this.cornerNodes.keys()){
			n = this.cornerNodes[k];
			n.drawNode();
		}
	}
}
