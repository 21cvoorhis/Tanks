import Graphics2D;
import Math;
import Random;
import TwoCansAlpha4;

/*
To do:
- Shooting
	- Lead: Aim at where the player will be (lead the shot). Calculate this with an expanding circle of aim (based on time) and the estimated position of the tank keeping it's current velocity (also based on time)
- Movement
	- Direct: Move towards the tank using A*
		- Find a path once at the start of the level, then just check where the player travels and only recalculate if they move tiles
	- Distance: Like Clyde from PacMan; approach directly unless it's within a certain distance from the tank, then try to escape the range of the tank for a few seconds.
		- If it can't escape (because it would hit a wall), have it switch to direct again.
	- Random? Pick a random node every few seconds and pathfind to it. This could be used for the mine tanks.
- Create a linear rotate function that uses the linear (prevent overshooting) 6 snippets code and takes in a parameter for speed (rads/sec)
	- Use this code on the body rotation function for bad tanks, because when they turn it can look really jerky
	- Also use it on the gun when the banked shot tank is rotating to fire (or when guns rotate to fire in general?)
	- Maybe use it when a tank is turning? or pass the smooth mixing a parameter to show how aggressively it should mix things
- Maybe add a little effect if a bullet passes a certain velocity to show it's a fast one? Like the fire from Wii Tanks


- For pathfinding, just allow neighbors to be connected by corners as well, and have the enemy tanks turn slower. That should solve 90% of the issues you're having.

*/

class BadTank : Tank{
	
	field shotType;
	field maxShotTime;
	field shotTimeLeft;
	field shotPos = null;
	
	field plantType;
	field maxPlantTime;
	field plantTimeLeft;
	
	field fleeDistance = 48; //only modify this in the constructor this if a single number is too broad to work
	field moveType;
	field moveTimeLeft = 0.0;
	field path = [];
	
	field rotateTimeLeft = 0.0;
	field rotateDirection = 0; //0 = none, 1 = clockwise, 2 = counterclockwise
	
	constructor(pos, radius, color, vel, shotType, maxShotTime, maxBullets, bulletSpeed, bulletBounces, plantType, maxPlantTime, maxMines, mineTime, moveType) : 
	base(pos, radius, color, vel, maxBullets, bulletSpeed, bulletBounces, maxMines, mineTime){
		
		this.shotType = shotType;
		this.maxShotTime = maxShotTime;
		this.shotTimeLeft = mix(this.maxShotTime, this.maxShotTime * Random.randomFloat(), 0.5);
		
		this.plantType = plantType;
		this.maxPlantTime = maxPlantTime;
		this.plantTimeLeft = mix(this.maxPlantTime, this.maxPlantTime * Random.randomFloat(), 0.5);
		
		this.moveType = moveType;
		
		this.rotateTimeLeft = mix(5, 5*Random.randomFloat(), 0.75);
	}
	
	//this should be updated to reflect the shooting behavior
	function updateBadTank(walls, wallSegments, tanks, gridNodes, cornerNodes){
		
		player = tanks[tanks.length-1];
		
		if(this.alive){
			
			this.tile = posToTile(this.pos);
			
			this.shotTimeLeft -= DT;
			this.plantTimeLeft -= DT;
			this.moveTimeLeft -= DT;
			this.rotateTimeLeft -= DT;
			
			this.bodyCollisionDie(tanks);
			this.bodyCollisionWalls(walls);
			
			if(player.alive){
				
				//decide vAngle for next frame with movement function
				switch (this.moveType) {
					case MoveType.DIRECT:
						this.directMove(player, gridNodes, wallSegments);
						break;
					case MoveType.RANDOM:
						this.randomMove(gridNodes);
						break;
				}
				
				//shooting functions
				switch (this.shotType) {
					case ShotType.NONE:
						this.rotateGun();
						break;
					case ShotType.DIRECT:
						this.directShot(walls, wallSegments, tanks, player);
						break;
					case ShotType.BANKED:
						this.bankedShot(walls, wallSegments, tanks, player);
						break;
				}
				
				//planting functions
				switch (this.plantType) {
					case PlantType.YES:
						this.yesPlant();
						break;
				}
				
			}else{
				this.rotateGun();
				this.vAngle = null;
			}
			
		}
		
	}
	
	function directMove(target, cornerNodes, wallSegments){
		
		if( (!listsEqual(this.tile, target.tile)) && ((this.path.length == 0) || !listsEqual(target.tile, this.path[this.path.length-1].tile)) ){
			this.path = this.findCornerPath(this.tile, target.tile, cornerNodes, wallSegments);
		}
		
		if(this.path.length == 0){
			this.vAngle = null;
		}else{
			if(listsEqual(this.path[0].tile, this.tile) && Math.abs(this.pos[0]-this.path[0].pos[0]) < 10 && Math.abs(this.pos[1]-this.path[0].pos[1]) < 10){
				this.path.remove(0);
			}
			try{
				this.target[0] = this.path[0].pos[0] - this.pos[0];
				this.target[1] = this.path[0].pos[1] - this.pos[1];
				this.vAngle = Math.arctan(this.target[1], this.target[0]);
			}catch(Core.IndexOutOfRangeException){
				this.vAngle = null;
			}
		}
		
	}
	
	function randomMove(gridNodes){
		
		target = gridNodes[gridNodes.keys().choice()];
		
		if((this.moveTimeLeft <= 0) || (this.path.length == 0)){
			this.path = this.findPath(findNode(this.tile, gridNodes), findNode(target.tile, gridNodes), gridNodes);
			this.moveTimeLeft = mix(5, 5*Random.randomFloat(), 0.5);
		}
		
		if(this.path.length == 0){
			this.vAngle = null;
		}else{
			if(listsEqual(this.path[0].tile, this.tile) && Math.abs(this.pos[0]-this.path[0].pos[0]) < 10 && Math.abs(this.pos[1]-this.path[0].pos[1]) < 10){
				this.path.remove(0);
			}
			try{
				this.target[0] = this.path[0].pos[0] - this.pos[0];
				this.target[1] = this.path[0].pos[1] - this.pos[1];
				this.vAngle = Math.arctan(this.target[1], this.target[0]);
			}catch(Core.IndexOutOfRangeException){
				this.vAngle = null;
			}
		}
		
	}
	
	/*function findCornerPath(startTile, endTile, cornerNodes, wallSegments){
		
		tempCornerNodes = {};
		
		for(k : cornerNodes.keys()){
			tempCornerNodes[k] = new Node(cornerNodes[k].tile, 1);
		}
		
		startNode = new Node(startTile, 1);
		tempCornerNodes[tileToIndex(startTile)] = startNode;
		
		endNode = new Node(endTile, 1);
		tempCornerNodes[tileToIndex(endTile)] = endNode;
		
		for(k : tempCornerNodes.keys()){
			
			tempCornerNodes[k].getCornerNeighbors(tempCornerNodes, wallSegments);
			
		}
		
		return this.findPath(startNode, endNode, tempCornerNodes);
	
	}*/
	
	function findPath(startNode, endNode, nodes){
		
		nextNodes = [[startNode, 0]]; //each term is the node and the cost to get to that node
		
		cameFrom = {};
		cameFrom[startNode] = null;
		
		pathCost = {};
		pathCost[startNode] = 0;
		
		path = [];
		
		while(nextNodes.length > 0){
			
			current = nextNodes[0][0];
			currentIndex = 0;
			lowestCost = nextNodes[0][1];
			for(i = 0; i<nextNodes.length; i++){
				if(lowestCost > nextNodes[i][1]){
					current = nextNodes[i][0];
					currentIndex = i;
					lowestCost = nextNodes[i][1];
				}
			}
			
			if(current == endNode){
				break;
			}
			
			for(i = 0; i<current.neighbors.length; i++){
				
				next = current.neighbors[i];
				newCost = pathCost[current] + next.weight;
				
				if(!pathCost.contains(next) || newCost < pathCost[next]){
					
					pathCost[next] = newCost;
					nextNodes.add([next, newCost + next.heuristic(startNode, endNode)]);
					cameFrom[next] = current;
				}
				
			}
			
			nextNodes.remove(currentIndex);
			
		}
		
		current = endNode;
		
		if(cameFrom.get(current) == null){
			return [];
		}
		
		while(cameFrom[current] != null){
			path.add(current);
			current = cameFrom[current];
		}
		
		//removable!!!!!!!!!!!!!!!!!!!!!
		for(k : nodes.keys()){
			n = nodes[k];
			n.color = [0, 0, 255];
		}
		for(n : path){
			n.color[0] = 255;
		}
		
		path.reverse();
		return path;
		
	}
	
	function rotateGun(){
	
		if(this.vAngle == null){ //tank is stationary, rotate quasi randomly
		
			if(this.rotateDirection == 1){
				this.gAngle -= Math.PI*DT/3.0;
			}else if(this.rotateDirection == 2){
				this.gAngle += Math.PI*DT/3.0;
			}
			
			if(this.gAngle>Math.PI){
				this.gAngle -= 2*Math.PI;
			}else if(this.gAngle<-Math.PI){
				this.gAngle += 2*Math.PI;
			}
			
			if(this.rotateTimeLeft <= 0){
				if(this.rotateDirection == 0){
					this.rotateDirection = Random.randomInt(1, 3);
				}else{
					this.rotateDirection = 0;
				}
				this.rotateTimeLeft = mix(3, 3*Random.randomFloat(), 0.5);
			}
			
		}else{ //tank isn't stationary, follow the tank's movement
			
			this.gAngle = smoothRotate(this.gAngle, this.vAngle);
			
		}
		
	}
	
	function clearShot(wallSegments, tanks, sourcePos, targetPos, exclude){ //exclude is one passed segment to ignore
		
		for(s : wallSegments){
			if(s != exclude && segmentSegmentCollision(s, [sourcePos, targetPos])){
				return false;
			}
		}
		for(i = 0; i<tanks.length-1; i++){
			if(tanks[i].pos != this.pos && tanks[i].alive && circleSegmentCollision(tanks[i].pos, tanks[i].r, [sourcePos, targetPos])){
				return false;
			}
		}
		
		return true;
	}
	
	function directShot(walls, wallSegments, tanks, player){
		
		sAngle = Math.arctan(player.pos[1]-this.pos[1], player.pos[0]-this.pos[0]);
		count = 0;
		
		if(this.clearShot(wallSegments, tanks, this.pos, player.pos, null)){ //you have a clear shot
			this.gAngle = smoothRotate(this.gAngle, sAngle);
			//take the shot if the gAngle is close to sAngle and the shotTimer is done
			if(this.shotTimeLeft <= 0 && Math.abs(this.gAngle - sAngle) < 0.01){
				this.shotTimeLeft = mix(this.maxShotTime, this.maxShotTime * Random.randomFloat(), 0.5); //mix percent is how random the shots are
				this.shoot(walls);
				return null;
			}
		}else{
			this.rotateGun();
			return null;
		}
		
	}
	
	function bankedShot(walls, wallSegments, tanks, player){
		
		if(this.shotTimeLeft <= 0 && this.shotPos == null){
			
			sAngle = 0.0;
			target = player.pos.clone();
			bouncePoints = [];
			validWallSegments = [];
			
			for(s : wallSegments){
				
				target = player.pos.clone();
				// determine if wall is x or y and reflect appropriately
				if(s[0][0] == s[1][0]){ //segment x's are the same, reflect the x value
					
					target[0] += 2*(s[0][0] - target[0] + 0.00001); //nudged to avoid the target falling on the same axis as this.pos
					
				}else if(s[0][1] == s[1][1]){ //segment y's are the same, reflect the y value
					
					target[1] += 2*(s[0][1] - target[1] + 0.00001);
					
				}
				
				if(segmentSegmentCollision(s, [this.pos, target])){
					validWallSegments.add(s);
					bouncePoints.add(segmentSegmentIntersection(s, [this.pos, target]));
				}
				
			}
			
			for(i = 0; i < validWallSegments.length; i++){
				s = validWallSegments[i];
				b = [bouncePoints[i][0] + 0.00001, bouncePoints[i][1] + 0.00001];
				
				//check for a clear shot to the player, and make sure the gun won't be shooting into a wall or the shot won't reflect back into the tank shooting
				if(this.clearShot(wallSegments, tanks, this.pos, b, s) && this.clearShot(wallSegments, tanks,  b, player.pos, s) && !circleSegmentCollision(this.pos, this.r*1.5, s) && !circleSegmentCollision(this.pos, this.collisionR, [b, player.pos])){
					this.shotPos = b;
				}
			}
		}
		
		if(this.shotPos != null){
			
			sAngle = Math.arctan(this.shotPos[1]-this.pos[1], this.shotPos[0]-this.pos[0]);
			this.gAngle = smoothRotate(this.gAngle, sAngle);
			if(Math.abs(this.gAngle - sAngle) < 0.01){
				this.shotTimeLeft = mix(this.maxShotTime, this.maxShotTime * Random.randomFloat(), 0.5); //mix percent is how random the shots are
				this.shoot(walls);
				this.shotPos = null;
			}
			
		}else{
			this.directShot(walls, wallSegments, tanks, player); //if all else fails, try a direct shot
			return null;
		}
		
	}
	
	function yesPlant(){
		
		if(this.plantTimeLeft <= 0){
			this.plant();
			this.plantTimeLeft = mix(this.maxPlantTime, this.maxPlantTime * Random.randomFloat(), 0.5);
		}
		
	}
	
}