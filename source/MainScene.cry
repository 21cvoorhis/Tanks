import Graphics2D;
import Graphics2DText;
import Math;
import Random;
import Resources;
import TwoCansAlpha4;

/*
To-do:
- Make a seperate enemy tanks class
	- Give the bad tanks AI! Start with the stationary ricochet shot tank, work up from there
	- For tank movement, use A*. Try experimenting with different distance finding methods (h(n) formulas) to see which gives the best result.
	- You can also reference the other Wii Tanks spinoff from GitHub
- Have tanks not intersect each other, use the 6 snippets interative constraint solving code to do that
	- Make a list of all tanks currently touching
	- Run the constraint solving function for each pair
	- If there are still collisions, run it again
- Add switching levels, and some kind of menu system
	- Give an intro to each level before starting it (like Wii Tanks)
- Optimize the wallSegments list to merge segments together if they make a continuous line
	- If all 4 x coords or y coords match and they share a point (s1[0] = s2[1] or s1[1] = s2[0]) just take the top and bottom of the other coords and make a new segment out of those
- Find some way to put all of the collision algorithm stuff into another file. Maybe these functions exist on the title screen where you start so they don't have to be on the level? idk
	- You could also have a dummy scene that routes straight to the title screen that contains all these functions, and it's just the start scene when you boot the game.
- Give bullets outlines
- Bucket Collisions (from 6 snippets), bucket size could just be the size of a wall?
*/

const BR = 127.0; //background r
const BG = 127.0; //background g
const BB = 127.0; //background b
const DT = (1.0/60.0);
const WIDTH = 640.0;
const HEIGHT = 480.0;

enum ShotType { NONE, DIRECT, BANKED, LEAD }
enum PlantType { NONE, YES }
enum MoveType { NONE, DIRECT, DISTANCE }

//mix
function mix(start, end, amount){
	return (1-amount)*start + amount*end;
}

function mixColor(c1, c2, amount){
	r = mix(c1[0], c2[0], amount);
	g = mix(c1[1], c2[1], amount);
	b = mix(c1[2], c2[2], amount);
	return [r, g, b];
}

function smoothRotate(current, target){ //smoothly interpolate between two angles
	
	//checks to see if they are further than pi apart, and adjust target by 2pi to be closer to current
	if(Math.abs(current-target) > Math.PI){
		if(target > 0){
			target = target - (2*Math.PI);
		}else{
			target = target + (2*Math.PI);
		}
	}
	
	//uses exponential smoothing with 3 mix values to make the tank turn smoothly
	if(Math.abs(current-target) > Math.PI/4){
		current = mix(current, target, 0.1);
	}else if(Math.abs(current-target) > Math.PI/8){
		current = mix(current, target, 0.2);
	}else if(Math.abs(current-target) > 0.00001){
		current = mix(current, target, 0.3);
	}else{
		current = target;
	}
	
	//adjust bAngle back by 2pi
	if(current>Math.PI){
		return current - 2*Math.PI;
	}else if(current<-Math.PI){
		return current + 2*Math.PI;
	}
	return current;
}

//math
function triangleArea(x1, y1, x2, y2, x3, y3){
	return Math.abs(((x1*y2)+(x2*y3)+(x3*y1)-(y1*x2)-(y2*x3)-(y3*x1))/2.0);
}

//collision
function pointRectCollision(point, rect){
	return
		point[0] > rect.left &&
		point[0] < rect.right &&
		point[1] > rect.top &&
		point[1] < rect.bottom;
}

function pointCircleCollision(point, circlePos, circleR) {
	dx = point[0] - circlePos[0];
	dy = point[1] - circlePos[1];
	return dx ** 2 + dy ** 2 < circleR ** 2;
}

function pointSegmentCollision(point, s) {
	
	d1 = (((s[0][0] - point[0])**2) + ((s[0][1] - point[1])**2))**0.5;
	d2 = ((s[1][0] - point[0])**2 + (s[1][1] - point[1])**2)**0.5;
	
	lineLen = (((s[1][0] - s[0][0])**2) + ((s[1][1] - s[0][1])**2))**0.5;
	
	buffer = 0.1;    // higher # = less accurate
	
	if (d1+d2 >= lineLen-buffer && d1+d2 <= lineLen+buffer) {
		return true;
	}
	return false;
}

function pointQuadCollision(point, quadPoints){
	
	qTri1 = triangleArea(quadPoints[0][0], quadPoints[0][1], quadPoints[1][0], quadPoints[1][1], quadPoints[2][0], quadPoints[2][1]);
	qTri2 = triangleArea(quadPoints[2][0], quadPoints[2][1], quadPoints[3][0], quadPoints[3][1], quadPoints[0][0], quadPoints[0][1]);
	quadArea = qTri1 + qTri2;
	
	pTris = [];
	for(i = 0; i<4; i++){
		if(i<3){
			pTris.add(triangleArea(point[0], point[1], quadPoints[i][0], quadPoints[i][1], quadPoints[i+1][0], quadPoints[i+1][1]));
		}else{
			pTris.add(triangleArea(point[0], point[1], quadPoints[i][0], quadPoints[i][1], quadPoints[0][0], quadPoints[0][1]));
		}
	}
	pArea = pTris[0] + pTris[1] + pTris[2] + pTris[3];
	
	return !(pArea>quadArea);
}

function circleCircleCollision(c1pos, c1r, c2pos, c2r) {
	dx = c1pos[0] - c2pos[0];
	dy = c1pos[1] - c2pos[1];
	return (dx ** 2) + (dy ** 2) < (c1r + c2r) ** 2;
}

function circleRectCollision(circlePos, circleR, rect){
    if (circlePos[0] + circleR < rect.left) return false;
    if (circlePos[0] - circleR > rect.right) return false;
    if (circlePos[1] + circleR < rect.top) return false;
    if (circlePos[1] - circleR > rect.bottom) return false;

    dx = null;
    dy = null;
    if (circlePos[0] < rect.left) {
        if (circlePos[1] < rect.top) {
            dx = circlePos[0] - rect.left;
            dy = circlePos[1] - rect.top;
        } else if (circlePos[1] > rect.bottom) {
            dx = circlePos[0] - rect.left;
            dy = circlePos[1] - rect.bottom;
        }
    } else if (circlePos[0] > rect.right) {
        if (circlePos[1] < rect.top) {
            dx = circlePos[0] - rect.right;
            dy = circlePos[1] - rect.top;
        } else if (circlePos[1] > rect.bottom) {
            dx = circlePos[0] - rect.right;
            dy = circlePos[1] - rect.bottom;
        }
    }

    if (dx != null) {
        return dx ** 2 + dy ** 2 < circleR ** 2;
    }

    return true;
}

function circleSegmentCollision(circlePos, circleR, s){
	
	inside1 = pointCircleCollision(s[0], circlePos, circleR);
	inside2 = pointCircleCollision(s[1], circlePos, circleR);
	if (inside1 || inside2){
		return true;
	}
	
	distX = s[0][0] - s[1][0];
	distY = s[0][1] - s[1][1];
	len = ((distX*distX) + (distY*distY))**0.5;
	
	// get dot product of the line and circle
	dot = (((circlePos[0]-s[0][0])*(s[1][0]-s[0][0])) + ((circlePos[1]-s[0][1])*(s[1][1]-s[0][1]))) / (len**2);
	
	// find the closest point on the line
	closestX = s[0][0] + (dot * (s[1][0]-s[0][0]));
	closestY = s[0][1] + (dot * (s[1][1]-s[0][1]));
	
	onS = pointSegmentCollision([closestX, closestY], s);
	if (!onS){
		return false;
	}
	
	distX = closestX - circlePos[0];
	distY = closestY - circlePos[1];
	distance = ((distX**2) + (distY**2))**0.5;

	if (distance <= circleR) {
		return true;
	}
	return false;
}

function segmentSegmentIntersection(s0, s1){ //https://www.geeksforgeeks.org/check-if-two-given-line-segments-intersect/
	
	o1 = orientation(s0[0], s0[1], s1[0]);
	o2 = orientation(s0[0], s0[1], s1[1]);
	o3 = orientation(s1[0], s1[1], s0[0]);
	o4 = orientation(s1[0], s1[1], s0[1]);
	
    // General case
    if(o1 != o2 && o3 != o4){
		return true;
	}
	
    // Special Cases
    // s0[0], s1[0] and s0[1] are collinear and s0[1] lies on segment p1q1
    if(o1 == 0 && onSegment(s0[0], s0[1], s1[0])){ 
		return true;
	}
    // s0[0], s1[0] and s1[1] are collinear and s1[1] lies on segment p1q1
    if(o2 == 0 && onSegment(s0[0], s1[1], s1[0])){ 
		return true;
	}
    // s0[1], s1[1] and s0[0] are collinear and s0[0] lies on segment p2q2
    if (o3 == 0 && onSegment(s0[1], s0[0], s1[1])){ 
		return true;
	}
     // s0[1], s1[1] and s1[0] are collinear and s1[0] lies on segment p2q2
    if(o4 == 0 && onSegment(s0[1], s1[0], s1[1])){ 
		return true;
	}
    return false; // Doesn't fall in any of the above cases
	
}
function orientation(p0, p1, p2){
	
	val = ((p1[1] - p0[1]) * (p2[0] - p1[0])) - ((p1[0] - p0[0]) * (p2[1] - p1[1]));
	
	if(val == 0){
		return 0; //collinear
	}
	return (val > 0)? 1: 2; //1 = clockwise, 2 = counterclockwise
}
function onSegment(p0, p1, p2){
    if (p1[0] <= max(p0[0], p2[0]) && p1[0] >= Math.min(p0[0], p2[0]) &&
        p1[1] <= max(p0[1], p2[1]) && p1[1] >= Math.min(p0[1], p2[1])){
       return true;
	}
    return false;
}

function getSegmentsIntersection(s0, s1){
	//ray's starting x and y points (px and py), and parametric component directions (dx and dy)
	r_px = s0[0][0];
	r_py = s0[0][1];
	r_dx = (s0[1][0]-r_px);
	r_dy = (s0[1][1]-r_py);
	
	//same as above for the line segment
	s_px = s1[0][0];
	s_py = s1[0][1];
	s_dx = (s1[1][0]-s_px);
	s_dy = (s1[1][1]-s_py);
	
	//Find if the lines are parallel, if so there's no intersection
	r_mag = (((r_dx*r_dx)+(r_dy*r_dy))**0.5);
	s_mag = (((s_dx*s_dx)+(s_dy*s_dy))**0.5);
	
	//check for /0 error
	if(r_mag==0){
		return null;
	}
	
	if(r_dx/r_mag==s_dx/s_mag && r_dy/r_mag==s_dy/s_mag){
		return null;
	}
	
	//find T1 and T2, for the parametric equations
	try{
		t2 = ((r_dx*(s_py-r_py)) + (r_dy*(r_px-s_px)))/((s_dx*r_dy) - (s_dy*r_dx));
		t1 = (s_px+(s_dx*t2)-r_px)/r_dx;
	}catch(Exception e){
		//catches /0 errors when lines are straight horizontal/vertical
		t2 = ((r_dx*(s_py-r_py)) + (r_dy*(r_px-s_px)))/((s_dx*r_dy) - (s_dy*r_dx));
		t1 = (s_py+s_dy*t2-r_py)/r_dy; //this is added from my previous version because only r_dx ever throws an error
	}
	
	//if the parametric T values are past these parameters the intersection isn't on the segments
	if(t1<0.0 || t1>1.0){
		return null;
	}
	if(t2<-0.00001 || t2>1.00001){
		return null;
	}
	
	//otherwise, you're good, and can plug in all the variables you just found to find the point of intersection [x, y, t]
	return [r_px+(r_dx*t1), r_py+(r_dy*t1), t1];
	
}

//misc. code
function pointsToSegments(points){
	segments = [];
	for(i = 0; i<points.length; i++){
		if(i<points.length-1){
			segments.add([points[i].clone(), points[i+1].clone()]);
		}else{
			segments.add([points[i].clone(), points[0].clone()]);
		}
	}
	return segments;
}

/*
If all 4 x coords or y coords match and they share a point (s1[0] = s2[1] or s1[1] = s2[0]) just take the top and bottom of the other coords and make a new segment out of those
Sort all unique segments into x and y groups? then into each interval and combine each interval? (list for 300.0x, 240.0x, etc. maybe)
*/
function findWallSegments(segments){
	
	u = []; //unique segments list
	x = []; //list of x segments
	y = []; //list of y segments
	duplicate = false;
	
	//find duplicate segments (two walls on top of each other) and remove both of them
	for(s : segments){
		duplicate = false;
		for(i = 0; i < u.length; i++){
			if(segmentsEqual(u[i], s)){
				u.remove(i);
				duplicate = true;
			}
		}
		if(!duplicate){
			u.add(s);
		}
	}
	
	for(s : u){
		if(s[0][1] == s[1][1]){
			x.add(s);
		}else{
			y.add(s);
		}
	}
	
	return u;
	
}

function segmentsEqual(s0, s1){
	return
		(s0[0][0] == s1[0][0] &&
		s0[0][1] == s1[0][1] &&
		s0[1][0] == s1[1][0] &&
		s0[1][1] == s1[1][1]) ||
		(s0[0][0] == s1[1][0] &&
		s0[0][1] == s1[1][1] &&
		s0[1][0] == s1[0][0] &&
		s0[1][1] == s1[0][1]);
}

class MainScene : AbstractScene {
	
	field backdropColor = [BR, BG, BB];
	
	field player;
	field playerColor = [63, 63, 255];
	field tanks = []; //list of all the tanks
	
	field fileName = "levels/TestLevel.txt";
	field mapText;
	field wallMapText; //doc but only the walls, for pathfinding
	field walls = [];
	field wallSegments = [];
	field wallColor = [63, 63, 63];
	
	field mousePos;
	
	constructor() : base() {
		
		//border walls
		this.walls.add(new Wall([0,0], 20, HEIGHT, this.wallColor));
		this.walls.add(new Wall([WIDTH-20,0], 20, HEIGHT, this.wallColor));
		this.walls.add(new Wall([0,0], WIDTH, 20, this.wallColor));
		this.walls.add(new Wall([0,HEIGHT-20], WIDTH, 20, this.wallColor));
		
		this.mapText = this.getMapText(this.fileName);
		for(i = 0; i<this.mapText.length; i++){
			switch(this.mapText[i]){
				case 'W':
					this.walls.add(new Wall([20.0+40*(i%15), 20.0+40*Math.floor(i/15)], 40.0, 40.0, this.wallColor));
					break;
				case 'P':
					this.player = new Tank([40+40*(i%15), 40+40*Math.floor(i/15)], 20.0, this.playerColor, 100.0, 5, 200.0, 1, 2, 10.0);
					break;
				case 'S': //nonmoving direct shot
					this.tanks.add(new BadTank([40+40*(i%15), 40+40*Math.floor(i/15)], 20.0, [191, 63, 63], 100.0, ShotType.DIRECT, 4.0, 5, 200.0, 1, PlantType.NONE, 0, 2, 10.0, MoveType.NONE));
					break;
				case 'R': //nonmoving ricochet shot
					this.tanks.add(new BadTank([40+40*(i%15), 40+40*Math.floor(i/15)], 20.0, [255, 63, 0], 100.0, ShotType.BANKED, 5.0, 5, 200.0, 1, PlantType.NONE, 0, 2, 10.0, MoveType.NONE));
					break;
				case 'M': //moving tank with no attacks
					this.tanks.add(new BadTank([40+40*(i%15), 40+40*Math.floor(i/15)], 20.0, [255, 63, 0], 100.0, ShotType.NONE, 5.0, 5, 200.0, 1, PlantType.NONE, 0, 2, 10.0, MoveType.DIRECT));
					break;
			}
		}
		
		this.wallMapText = this.getWallMapText(this.mapText);
		
		for(wall : this.walls){
			for(segment : wall.segments){
				this.wallSegments.add(segment);
			}
		}
		
		this.wallSegments = findWallSegments(this.wallSegments);
		
		this.tanks.add(this.player);
		
		this.mousePos = [0,0];
		
	}
	
	function getMapText(fileName){
		mapText = "";
		fileText = Resources.readText(fileName);
		for(i = 0; i<fileText.length; i++){
			if(fileText[i]!='\n' && fileText[i]!='\r'){
				mapText+=fileText[i];
			}
		}
		return mapText;
	}
	
	function getWallMapText(mapText){
		wallMapText = "";
		
		for(i = 0; i<mapText.length; i++){
			if(mapText[i] == 'W'){
				wallMapText+='W';
			}else{
				wallMapText+='-';
			}
		}
		return wallMapText;
	}
	
	function update(inputManager, events) {
		
		this.mousePos = inputManager.getMousePosition();
		
		//player movement
		this.player.target[0] = 0;
		this.player.target[1] = 0;
		if(inputManager.isKeyPressed(KeyboardKey.LEFT) || inputManager.isKeyPressed(KeyboardKey.A)) {
			this.player.target[0]--;
		}
		if (inputManager.isKeyPressed(KeyboardKey.RIGHT) || inputManager.isKeyPressed(KeyboardKey.D)) {
			this.player.target[0]++;
		}
		if(inputManager.isKeyPressed(KeyboardKey.UP) || inputManager.isKeyPressed(KeyboardKey.W)) {
			this.player.target[1]--;
		}
		if (inputManager.isKeyPressed(KeyboardKey.DOWN) || inputManager.isKeyPressed(KeyboardKey.S)) {
			this.player.target[1]++;
		}
		if (inputManager.isKeyPressedThisFrame(KeyboardKey.SPACE)) {
			if(this.player.alive){
				this.player.plant();
			}
		}
		if (inputManager.isKeyPressed(KeyboardKey.R)) {
			this.player.alive = true;
		}
		
		this.player.vAngle = Math.arctan(this.player.target[1], this.player.target[0]);
		
		if(!((this.player.target[0]==0) && (this.player.target[1]==0))){ //if there is a velocity input
			this.player.motion = true;
		}else{
			this.player.motion = false;
		}
		
		this.player.gAngle = Math.arctan(this.mousePos[1]-this.player.pos[1], this.mousePos[0]-this.player.pos[0]);
		
		for (event : events) {
			switch (event.type) {
				case EventType.MOUSE_PRESS:
					if(this.player.alive){
						this.player.shoot(this.walls);
					}
					break;
			}
		}
		
		/*
		All elements of the tanks have to be updated in groups to keep collision information correct, and in this order because they can cause a chain reaction.
		Also, all positions need to be calculated before any collisions.
		I'd love to use for(tank : this.tanks) instead of the standard for loops, but it can throw errors if there are no tanks, bullets, etc.
		Overall, I hate how this code looks and it feels highly inefficient, but it's the best I could come up with that doesn't throw errors everywhere.
		*/
		
		//update object data
		for(i = 0; i<this.tanks.length; i++){
			if(this.tanks[i].alive){
				this.tanks[i].updateObject();
			}
			for(j = 0; j<this.tanks[i].bullets.length; j++){
				this.tanks[i].bullets[j].updateObject();
			}
			for(j = 0; j<this.tanks[i].mines.length; j++){
				this.tanks[i].mines[j].updateObject();
			}
			for(j = 0; j<this.tanks[i].explosions.length; j++){
				this.tanks[i].explosions[j].updateObject();
			}
		}
		
		for(i = 0; i<this.tanks.length; i++){
			for(j = 0; j<this.tanks[i].bullets.length; j++){
				this.tanks[i].bullets[j].updateBullet(this.walls, this.wallSegments, this.tanks);
			}
		}
		for(i = 0; i<this.tanks.length; i++){
			for(j = 0; j<this.tanks[i].mines.length; j++){
				this.tanks[i].mines[j].updateMine(this.tanks);
			}
		}
		for(i = 0; i<this.tanks.length; i++){
			for(j = 0; j<this.tanks[i].explosions.length; j++){
				this.tanks[i].explosions[j].updateExplosion();
			}
		}
		for(i = 0; i<this.tanks.length-1; i++){
			if(this.tanks[i].alive){
				this.tanks[i].updateBadTank(this.walls, this.wallSegments, this.tanks);
			}
		}
		if(this.player.alive){
			this.player.updateTank(this.walls, this.tanks);
		}
		
		//update object lists
		for(i = 0; i<this.tanks.length; i++){
			for(j = 0; j<this.tanks[i].bullets.length; j++){
				if(!this.tanks[i].bullets[j].alive){
					if(this.tanks[i].bullets[j].explode){
						this.tanks[i].explosions.add(new Explosion(this.tanks[i].bullets[j].pos.clone(), this.tanks[i].bulletR*2.0, [255, 0, 0], [255, 127, 0]));
					}
					this.tanks[i].bullets.remove(j);
				}
			}
			for(j = 0; j<this.tanks[i].mines.length; j++){
				if(!this.tanks[i].mines[j].alive){
					this.tanks[i].explosions.add(new Explosion(this.tanks[i].mines[j].pos.clone(), this.tanks[i].mineR*6.0, [255, 0, 0], [255, 127, 0]));
					this.tanks[i].mines.remove(j);
				}
			}
			for(j = 0; j<this.tanks[i].explosions.length; j++){
				if(!this.tanks[i].explosions[j].alive){
					this.tanks[i].explosions.remove(j);
				}
			}
		}
		
	}
	
	function render() {
		
		Graphics2D.Draw.fill(BR, BG, BB);
		
		for(i = 0; i<this.tanks.length; i++){
			for(j = 0; j<this.tanks[i].explosions.length; j++){
				this.tanks[i].explosions[j].drawExplosion();
			}
			for(j = 0; j<this.tanks[i].bullets.length; j++){
				this.tanks[i].bullets[j].drawBullet();
			}
			for(j = 0; j<this.tanks[i].mines.length; j++){
				this.tanks[i].mines[j].drawMine();
			}
		}
		
		for(tank : this.tanks){
			if(tank.alive){
				tank.drawTank();
			}
		}
		
		for(wall : this.walls){
			wall.drawWallOutline();
		}
		for(wall : this.walls){
			wall.drawWallInside();
		}
		
		//testing
		for(s : this.wallSegments){
			Graphics2D.Draw.line(s[0][0], s[0][1], s[1][0], s[1][1], 5, 166, 0, 166);
		}
		for(s : this.wallSegments){
			Graphics2D.Draw.ellipse(s[0][0]-5, s[0][1]-5, 10, 10, 0, 255, 0);
		}
	}
}
